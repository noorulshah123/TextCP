┌─────────────────────────────────────────────────────────┐
│                    GitLab CI/CD Pipeline                 │
├─────────────────────────┬───────────────────────────────┤
│    Infrastructure       │        Data & Schema          │
│      (Terraform)        │         (Flyway)              │
├─────────────────────────┼───────────────────────────────┤
│ • Databases             │ • Table Structures            │
│ • Warehouses            │ • Column Modifications        │
│ • Users & Roles         │ • Data Migrations             │
│ • Security Policies     │ • Stored Procedure Logic      │
│ • Network Rules         │ • Historical Data Loads       │
│ • Resource Monitors     │ • Complex SQL Transformations │
└─────────────────────────┴───────────────────────────────┘

"Think of it like building a house. Terraform is your architect and general contractor - it handles the foundation, walls, plumbing, and electrical systems.
Flyway is your interior designer - it handles how you arrange and modify things inside the rooms."


Reason 1: State Management vs Sequential Migrations
"Terraform excels at managing infrastructure state. If someone manually changes a warehouse size in Snowflake, Terraform will detect this 'drift' and can correct it.
Flyway can't do this - it only knows what migrations have been applied, not what the current state should be."

Reason 2: Environment Replication
"Let me show you how easy it is to replicate environments with Terraform:"



Part 2: Snowflake Terraform Provider
What Can Be Managed?
The Snowflake Terraform provider can manage:
Account-Level Resources:

Users and Roles
Resource Monitors
Network Policies
Replication Groups

Database Objects:

Databases
Schemas
Tables
Views and Materialized Views
Stored Procedures
Functions (UDFs)
Sequences
File Formats
Stages

Access Control:

Role Grants
Privilege Grants
Row Access Policies
Masking Policies

Compute Resources:

Warehouses
Tasks
Streams
Pipes

Example: Complete Database Setup
hcl# Database
resource "snowflake_database" "app_db" {
  name                        = "APPLICATION_DB"
  data_retention_time_in_days = 7
  comment                     = "Application database"
}

# Schema
resource "snowflake_schema" "raw_data" {
  database = snowflake_database.app_db.name
  name     = "RAW_DATA"
  comment  = "Schema for raw data ingestion"
}

# Warehouse
resource "snowflake_warehouse" "compute_wh" {
  name           = "COMPUTE_WH"
  warehouse_size = "X-SMALL"
  auto_suspend   = 60
  auto_resume    = true
}

# Table
resource "snowflake_table" "customers" {
  database = snowflake_database.app_db.name
  schema   = snowflake_schema.raw_data.name
  name     = "CUSTOMERS"

  column {
    name     = "ID"
    type     = "NUMBER(38,0)"
    nullable = false
  }

  column {
    name = "NAME"
    type = "VARCHAR(100)"
  }

  column {
    name = "CREATED_AT"
    type = "TIMESTAMP_NTZ"
  }
}

# Role
resource "snowflake_role" "analyst" {
  name    = "ANALYST_ROLE"
  comment = "Role for data analysts"
}

# Grants
resource "snowflake_database_grant" "analyst_db" {
  database_name = snowflake_database.app_db.name
  privilege     = "USAGE"
  roles         = [snowflake_role.analyst.name]
}

Part 3: Flyway vs Terraform - Key Differences
Flyway (Current State)
Purpose: Database schema migration tool

Imperative approach: SQL scripts executed in sequence
Version-based migrations: V1__Create_table.sql, V2__Add_column.sql
One-way migrations: Applied sequentially, rollback requires new forward migration
Focus: Schema changes and data migrations
State tracking: Migration history table in database

Terraform (Target State)
Purpose: Infrastructure as Code for complete resource management

Declarative approach: Describe desired state
State-based management: Compares desired vs actual state
Bidirectional changes: Can create, update, and destroy
Focus: All Snowflake resources (not just schema)
State tracking: External state file (Terraform Cloud)

Migration Considerations
What Terraform Handles Well:

Infrastructure provisioning (databases, schemas, warehouses)
Access control and security
Resource configuration
Account-level settings

What Stays with SQL/Flyway:

Complex data migrations
Stored procedure logic (though structure managed by Terraform)
One-time data transformation scripts
Historical data loads


Part 4: Terraform Cloud Enterprise Integration
Benefits for Your Organization

Remote State Management

Centralized, encrypted state storage
State locking prevents conflicts
State versioning and rollback


Team Collaboration

Workspace-based organization
Role-based access control
Policy as Code with Sentinel


Private Module Registry

Share approved Snowflake modules
Version control for modules
Documentation and examples
